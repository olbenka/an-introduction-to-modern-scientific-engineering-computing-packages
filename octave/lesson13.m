#Урок 13
#дифференциальные уравнения.
#символьный метод
#dsolv(df) решение диф уравнения
#производная diff() - без символьных вычеслений вернет разность (difference)
#нужно задать для символьных вычислений pkg load symbolic
#syms - символьные переменные
#y' - y = 0;
# syms y(t)
# de = diff(y, t) - y == 0;
#sol = dsolve(de);
#можно указать начальные условия в dsolve
#можно задать порядок производной diff(y,t,2)
#вектор-столбец их уравнений системы, на вход dsolve()
#обращение к элементу структуры через точку soln = dsolve(sys); soln.x, soln.y;

#визуализация
#y' - 0.2xy = 0; y(0) = 0.3;
#xval = linspace(-5,5,100); plot(xval, #явный вид)
#из символьного выражения - sol2 = function_handle(sol1)
# plot(xval, sol2(xval));

#численный метод
#метод восходящих разностей
#dy/dx = (yi+1 - yi)/(xi+1 - xi)
#dydx = diff(y)./diff(x)
#метод насходящих разностей
#yi - yi-1
#центральные разности
#yi+1 - yi-1 не работает для крайних точек
#gradient()

#численное решение диффуров, завязано на коши (метод эйлера) - ошибку накапливает
#y' = f(x)
#a < x0 < x1 <xn < b
#xi+1 = a + h*xi
#метод рунге-кутты
#4х шаговый - формулы в фото
#ode45 - тот самый, есть еще двухшаговый ode23
#[t,y] = ode..(function_handle(ур-е 1 порядка обяз), [initial_time, final_time], [initial_cond_array]);

#пример
#y' = 2y; y(0) = 10, 0 <= t <= 3
#F = @(t,y) 2*y; t0 = 0; tfin = 3; y0 = 10; ode45(F, [t0, tfin], y0(может быть [y0,x0])); - будет график
#ty = ode45(F, [t0, tfin], y0); - будет вектор
#для систем - создать отдельно функцию, объединяющую уравнения - на фото

#если порядок не первый, то можно с помощью замен сделать их на порядок ниже
#создаем функцию, создаем систему (замена + подставленное) - фото

